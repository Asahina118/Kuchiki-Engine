How Render Passes Draw: Step-by-Step
Perfect understanding! Here's exactly how each pass works:

1. Renderer Setup (Once)
cpp
class Renderer {
    ShaderRegistry& m_shaders;
    GLuint m_shadowTexture, m_shadowFBO;  // Shadow map texture + FBO
    
public:
    Renderer(ShaderRegistry& shaders) : m_shaders(shaders) {
        setupShadowFramebuffer();  // Creates m_shadowTexture (1024x1024 depth)
    }
};
2. Shadow Pass - HOW IT DRAWS
cpp
void Renderer::renderShadows(const std::vector<RenderObject*>& objects) {
    // STEP 1: Bind shadow FBO (renders to shadowTexture, not screen)
    glBindFramebuffer(GL_FRAMEBUFFER, m_shadowFBO);
    glViewport(0, 0, 1024, 1024);  // Shadow map resolution
    
    // STEP 2: Bind shadow-only shader (no textures needed)
    auto shadowShader = m_shaders.get("shadow_depth");
    shadowShader->bind();
    shadowShader->setMat4("u_lightSpaceMatrix", lightSpaceMatrix);  // Light viewproj
    
    // STEP 3: Draw ALL opaque objects (no materials needed)
    for (auto obj : objects) {
        glBindVertexArray(obj->mesh->VAO);
        glDrawElements(GL_TRIANGLES, obj->mesh->indexCount, GL_UNSIGNED_INT, 0);
    }
    
    glBindFramebuffer(GL_FRAMEBUFFER, 0);  // Back to screen
}
3. Lighting Pass - HOW IT DRAWS
cpp
void Renderer::renderLighting(const std::vector<RenderObject*>& objects) {
    // STEP 1: Bind screen FBO + full viewport
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glViewport(0, 0, screenWidth, screenHeight);
    
    // STEP 2: Bind lighting shader
    auto lightingShader = m_shaders.get("pbr_lighting");
    lightingShader->bind();
    lightingShader->setMat4("u_shadowMatrix", lightSpaceMatrix);  // Pass shadow info
    lightingShader->setInt("u_shadowTexture", 5);  // Shadow texture in unit 5
    
    // STEP 3: Bind shadow texture (shared across ALL objects)
    glActiveTexture(GL_TEXTURE5);
    glBindTexture(GL_TEXTURE_2D, m_shadowTexture);
    
    // STEP 4: Draw objects with their materials
    for (auto obj : objects) {
        obj->material->bindTextures();  // Unit 0=albedo, 1=normal, 2=roughness...
        lightingShader->setMat4("u_modelMatrix", obj->transform);
        
        glBindVertexArray(obj->mesh->VAO);
        glDrawElements(GL_TRIANGLES, obj->mesh->indexCount, GL_UNSIGNED_INT, 0);
    }
}
4. Main Loop
cpp
void Renderer::renderFrame(const Scene& scene) {
    // Pass 1: Generate shadows for ALL objects
    renderShadows(scene.opaqueObjects);
    
    // Pass 2: Main lighting using shadows
    renderLighting(scene.opaqueObjects);
}
Key Insights
text
Shadow Pass:
- SAME geometry for ALL objects  
- NO material textures needed
- Renders to shadowTexture (not screen)

Lighting Pass:  
- SAME geometry + DIFFERENT materials per object
- ShadowTexture as shared input (texture unit 5)  
- Renders to screen
Your Mesh/Material Stay Pure
cpp
// Mesh: just geometry (pos, normal, uv in Vertex)
Mesh cubeMesh = loadCube();  

// Material: just appearance (textures, NO shaders)
Material goldMaterial{textures: {goldAlbedo, goldNormal, goldRough}};

RenderObject cube{&cubeMesh, &goldMaterial, transform};
Renderer wires it all together per pass. Clean AF.

Does this clarify the flow? Shadow pass is "geometry only". Lighting pass is "geometry + per-object materials + shadow input".